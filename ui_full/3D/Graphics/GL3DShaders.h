/*************************************************************************
**  openLISEM: a spatial surface water balance and soil erosion model
**  Copyright (C) 2010,2011  Victor Jetten
**  contact:
**
**  This program is free software: you can redistribute it and/or modify
**  it under the terms of the GNU General Public License as published by
**  the Free Software Foundation, either version 3 of the License, or
**  (at your option) any later version.
**
**  This program is distributed in the hope that it will be useful,
**  but WITHOUT ANY WARRANTY; without even the implied warranty of
**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
**  GNU General Public License for more details.
**
**  You should have received a copy of the GNU General Public License
**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
**
**  Author: Victor Jetten
**  Developed in: MingW/Qt/
**  website, information and code: http://lisem.sourceforge.net
**
*************************************************************************/

#ifndef Shaders3D
#define Shaders3D

#include <QtOpenGL/QGLWidget>
#include "QDebug"
#include <QVector>
#include <vector>
#include <QtOpenGL/QtOpenGL>
#include "csfMap.h"
#include "LisUIoutput.h"
#include "global.h"
#include <QString>
#include "ui_full/3D/GL3DWidget.h"

#define SHADER_NULL 0
class GL3DWidget;
class GL3DShader;


class GL3DShaders
{

public:

    QList<GL3DShader *> m_DefaultShaderList;
    QList<GL3DShader *> m_LoadedShaderList;

    GL3DShader * LoadShaderFromText(const char * text_ps,const char * text_vs, bool add = true,const char * text_tcs = SHADER_NULL,const char * text_tes = SHADER_NULL,const char * text_gs = SHADER_NULL);
    GL3DShader * LoadShaderFromFile(QString file_ps,QString file_vs, bool add = true,QString file_tcs="",QString file_tes = "",QString file_gs = "");

    GL3DShader * GetDefaultShader(int index);

    GL3DShader * copyshader;
    GL3DShader * blendshader;

    GL3DShaders()
    {

    };

    GL3DWidget * m_Widget;

    void Create(GL3DWidget * widget);
    void ClearUnused();
    void Destroy();

};

class GL3DShader
{


public:


    QOpenGLShaderProgram *m_program;

    bool is_created;
    bool from_text;
    QString source;

    int nr_using_ojects;

    GL3DShader()
    {

    };

    void LoadShaderFromText(GL3DWidget * widget,const char * text_ps,const char * text_vs,const char * text_tcs = SHADER_NULL,const char * text_tes = SHADER_NULL,const char * text_gs = SHADER_NULL);
    void LoadShaderFromFile(GL3DWidget * widget,QString file_ps,QString file_vs,QString file_tcs = "",QString file_tes = "",QString file_gs = "");

    void ActivateTextureOn(GL3DWidget * widget, GL3DTexture *t, const char * name, int slot);
    void ActivateTextureOn(GL3DWidget * widget, GLuint t, const char * name, int slot);

    void ClearShader();

};

#define GL3D_SHADER_SIMPLE 0
#define GL3D_SHADER_SKYBOX 1
#define GL3D_SHADER_SURFACE_TESSELATED 2
#define GL3D_SHADER_SURFACE_FLOW 3
#define GL3D_SHADER_VEGETATION 4
#define GL3D_SHADER_TEXTURED 5

/////////////////////////////////////////////////////////////////////////////////////
///Simple shader
/////////////////////////////////////////////////////////////////////////////////////
static const char *vertexShaderSource =
    "in highp vec3 posAttr;\n"
    "in lowp vec3 colAttr;\n"
    "uniform highp mat4 Cmatrix;\n"
    "uniform highp mat4 Mmatrix;\n"
    "out lowp vec4 col;\n"
    "void main() {\n"
    "   gl_Position = Cmatrix *vec4(posAttr, 1.0);\n"
    "   col = vec4(colAttr,1.0);\n"
    "}\n";
//;
static const char *fragmentShaderSource =
    "in lowp vec4 col;\n"
    "void main() {\n"
    "   gl_FragColor = col;\n"
    "}\n";
/////////////////////////////////////////////////////////////////////////////////////
///Simple skybox shader
/////////////////////////////////////////////////////////////////////////////////////
static const char *vertexShaderSource_SKYBOX =
    "in highp vec3 posAttr;\n"
    "in lowp vec3 colAttr;\n"
    "uniform highp mat4 Cmatrix;\n"
    "uniform highp mat4 Mmatrix;\n"
    "out vec3 texcoords;\n"
    "void main() {\n"
    "   gl_Position = Cmatrix *vec4(posAttr, 1.0);\n"
    "   texcoords = posAttr;\n"
    "}\n";

static const char *fragmentShaderSource_SKYBOX =
    "in vec3 texcoords;\n"
    "uniform samplerCube cubetexture;\n"
    "out vec4 frag_colour;\n"
    "void main() {\n"
    "   frag_colour = texture(cubetexture, texcoords);\n"
    "}\n";
/////////////////////////////////////////////////////////////////////////////////////
///Simple surface shader
/////////////////////////////////////////////////////////////////////////////////////
static const char *vertexShaderSource_SURFACE =
    "in highp vec3 posAttr;\n"
    "in lowp vec3 colAttr;\n"
    "uniform highp mat4 Cmatrix;\n"
    "uniform highp mat4 Mmatrix;\n"
    "out lowp vec4 col;\n"
    "void main() {\n"
    "   gl_Position = Cmatrix *vec4(posAttr, 1.0);\n"
    "   col = vec4(colAttr,1.0);\n"
    "}\n";
//;
static const char *fragmentShaderSource_SURFACE =
    "in lowp vec4 col;\n"
    "void main() {\n"
    "   gl_FragColor = col;\n"
    "}\n";
/////////////////////////////////////////////////////////////////////////////////////
///Simple surface shader Tesselated Test!
/////////////////////////////////////////////////////////////////////////////////////
static const char *vertexShaderSource_SURFACE_TESSELATED =
    "#version 400\n"
    "\n"
    "in highp vec3 posAttr;\n"
    "in lowp vec3 colAttr;\n"
    "uniform highp mat4 Cmatrix;\n"
    "uniform highp mat4 Mmatrix;\n"
    "out terrainVertex {\n"
    "    vec3 position;\n"
    "} Out;\n"
    "void main() {\n"
    "    Out.position = posAttr;\n"
    "}\n";
//;

static const char *tesselationcontrolShaderSource_SURFACE_TESSELATED =
    "#version 400\n"
    "\n"
    "layout(vertices = 3) out;\n"
    "in terrainVertex {\n"
    "   vec3 position; \n"
    "} In[]; \n"
    "\n"
    "out terrainVertex {\n"
    "   vec3 position; \n"
    "   flat float upscale; \n"
    "   flat vec3 referencepos; \n"
    "} Out[]; \n"
    "\n"
    "uniform sampler2D heightMap; \n"
    "\n"
    "uniform sampler2D microElevation; \n"
    "uniform float microElevationScaleX; \n"
    "uniform float microElevationScaleY; \n"
    "uniform float microElevationScaleZ; \n"
    "\n"
    "uniform float CellSize; \n"
    "uniform float SurfaceExtentX; \n"
    "uniform float SurfaceExtentZ; \n"
    "uniform float ElevationMin; \n"
    "uniform float ElevationMax; \n"
    "uniform highp mat4 Cmatrix;\n"
    "uniform highp mat4 Mmatrix;\n"
    "uniform highp vec3 Cposition;\n"
    "\n"
    "uniform float pixelsPerTriangleEdge = 50.0;\n"
    "uniform vec2 viewportSize;\n"
    "\n"
    "bool isEdgeInViewFrustum( const in vec4 p1, const in vec4 p2 )\n"
    "{\n"
    "   return !( ( p1.x < -p1.w && p2.x < -p2.w )\n"
    "           || ( p1.x >  p1.w && p2.x >  p2.w )\n"
    "           || ( p1.y < -p1.w && p2.y < -p2.w )\n"
    "           || ( p1.y >  p1.w && p2.y >  p2.w )\n"
    "           || ( p1.z < -p1.w && p2.z < -p2.w )\n"
    "           || ( p1.z >  p1.w && p2.z >  p2.w ) );\n"
    "}\n"
    "\n"
    "float calcTessellationLevel( const in vec4 v1, const in vec4 v2 )\n"
    "{\n"
    "    vec4 p1 = 0.5 * ( v1 + v2 );\n"
    "    vec4 p2 = p1;\n"
    "    p2.y += distance( v1, v2 );\n"
    "    p1 = p1 / p1.w;\n"
    "    p2 = p2 / p2.w;\n"
    "    float l = length( 0.5 * viewportSize * ( p1.xy - p2.xy ) );\n"
    "    return clamp( l / pixelsPerTriangleEdge, 0.01, 64.0 );\n"
    "}"
    "float calcNegativeTessellationLevelDist( float dist )\n"
    "{\n"
    "    return sqrt(dist);\n"
    "}"
    "float calcNegativeTessellationLevel( float in_ntess )\n"
    "{\n"
    "    if(in_ntess < 1.5){ return 1.0;}\n"
    "    if(in_ntess < 3.0){ return 2.0;}\n"
    "    if(in_ntess < 6.0){ return 4.0;}\n"
    "    if(in_ntess < 15.0){ return 8.0;}\n"
    "    if(in_ntess < 31.0){ return 16.0;}\n"
    "    if(in_ntess < 62.0){ return 32.0;}\n"
    "    return 64.0;\n"
    "}"
    "float calcNegativeTessellationLevelBelow( float in_ntess )\n"
    "{\n"
    "    if(in_ntess < 3.0){ return 1.0;}\n"
    "    if(in_ntess < 6.0){ return 2.0;}\n"
    "    if(in_ntess < 15.0){ return 4.0;}\n"
    "    if(in_ntess < 31.0){ return 8.0;}\n"
    "    if(in_ntess < 62.0){ return 16.0;}\n"
    "    return 32.0;\n"
    "}\n"
    "float calcNegativeTessellationLevelRemain( float in_ntess )\n"
    "{\n"
    "    float margin_bottom = 0.3;\n"
    "    float margin_top = 0.55;\n"
    "    if(in_ntess > 61.0 * (1.0-margin_bottom) && in_ntess < 62.0 * (1.0+margin_top)  ){ return 1.0;}\n"
    "    if(in_ntess > 31.0 * (1.0-margin_bottom) && in_ntess < 31.0 * (1.0+margin_top)  ){ return 1.0;}\n"
    "    if(in_ntess > 15.0 * (1.0-margin_bottom) && in_ntess < 15.0 * (1.0+margin_top)  ){ return 1.0;}\n"
    "    if(in_ntess > 6.0 * (1.0-margin_bottom) && in_ntess < 6.0 * (1.0+margin_top)  ){ return 1.0;}\n"
    "    if(in_ntess > 3.0 * (1.0-margin_bottom) && in_ntess < 3.0 * (1.0+margin_top) ){ return 1.0;}\n"
    "    if(in_ntess > 1.5 * (1.0-margin_bottom) && in_ntess < 1.5 * (1.0+margin_top) ){ return 1.0;}\n"
    "    return 0.0;\n"
    "}"
    "\n"       
    "\n"
    "float getElevation(float xpos, float zpos)\n"
    "{\n"
    "    vec2 texcoord = vec2(xpos / SurfaceExtentX, zpos/SurfaceExtentZ);\n"
    "    float heightmap = texture(heightMap,texcoord).r;\n"
    "    vec2 texcoord2 = vec2(mod(xpos,microElevationScaleX) /microElevationScaleX, mod(zpos,microElevationScaleZ) /microElevationScaleZ);\n"
    "    float heightmap2 = microElevationScaleY * texture(microElevation,texcoord2).r;\n"
    "    return heightmap + heightmap2;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    Out[gl_InvocationID].position = In[gl_InvocationID].position;\n"
    "    Out[gl_InvocationID].upscale = 0;\n"
    "    Out[gl_InvocationID].referencepos = In[0].position;\n"
    "\n"
    "    if(gl_InvocationID == 0)\n"
    "    {\n"
    "       \n"
    "       vec2 patchCornersXZ[3];\n"
    "       patchCornersXZ[0] = In[0].position.xz;   \n"
    "       patchCornersXZ[1] = In[1].position.xz;   \n"
    "       patchCornersXZ[2] = In[2].position.xz;   \n"
    "       \n"
    "       vec4 clipSpacePatchCorners[3];\n"
    "       for ( int i = 0; i < 3; i++ )\n"
    "       {\n"
    "           vec3 position;\n"
    "           position.xz= patchCornersXZ[i].xy;\n"
    "           position.y = getElevation(patchCornersXZ[i].x ,patchCornersXZ[i].y);\n"
    "           clipSpacePatchCorners[i] = Cmatrix *vec4(position, 1.0);\n"
    "       }\n"
    "\n"
    "       // Determine if we can cull this patch\n"
    "       if ( isEdgeInViewFrustum( clipSpacePatchCorners[0], clipSpacePatchCorners[2] )\n"
    "       || isEdgeInViewFrustum( clipSpacePatchCorners[0], clipSpacePatchCorners[1] )\n"
    "       || isEdgeInViewFrustum( clipSpacePatchCorners[1], clipSpacePatchCorners[2] ))\n"
    "       {\n"
    "           float tess_out_0 = calcTessellationLevel( clipSpacePatchCorners[0], clipSpacePatchCorners[1] ); \n"
    "           float tess_out_1 = calcTessellationLevel( clipSpacePatchCorners[0], clipSpacePatchCorners[2] ); \n"
    "           float tess_out_2 = calcTessellationLevel( clipSpacePatchCorners[1], clipSpacePatchCorners[2] ); \n"
    "           float tess_in_0 = max(max(tess_out_0,tess_out_1),tess_out_2);"
    "           \n"
    "           float margin = 0.1;\n"
    "           float n_tess = max(1.0,(1.0/tess_in_0) - 1.0);\n"
    "           if(n_tess > 1.0)\n"
    "           {\n"
    "               float n_tess_remain = calcNegativeTessellationLevelRemain(n_tess);"
    "               float n_tess_Below = calcNegativeTessellationLevelBelow(n_tess);"
    "               n_tess = calcNegativeTessellationLevel(n_tess);"
    "               \n"
    "               float modx = mod(floor(patchCornersXZ[0].x/CellSize),n_tess); \n"
    "               float mody = mod(floor(patchCornersXZ[0].y/CellSize),n_tess); \n"
    "               \n"
    "               float modx0 = n_tess > 0? mod(floor(patchCornersXZ[0].x/CellSize),(n_tess_Below )) : 0.0;\n"
    "               float mody0 = n_tess > 0? mod(floor(patchCornersXZ[0].y/CellSize),(n_tess_Below )) : 0.0;\n"
    "               \n"
    "               if(trunc(modx) == 0 && trunc(mody) == 0)\n"
    "               {\n"
    "                   gl_TessLevelOuter[0] = 1.0;\n"
    "                   gl_TessLevelOuter[1] = 1.0;\n"
    "                   gl_TessLevelOuter[2] = 1.0;\n"
    "                   gl_TessLevelInner[0] = 1.0;\n"
    "                   Out[gl_InvocationID].upscale = n_tess;\n"
    "               \n"
    "               }else if(n_tess_remain > 0.5 && trunc(modx0) == 0 && trunc(mody0) == 0)\n"
    "               {\n"
    "                   gl_TessLevelOuter[0] = 1.0;\n"
    "                   gl_TessLevelOuter[1] = 1.0;\n"
    "                   gl_TessLevelOuter[2] = 1.0;\n"
    "                   gl_TessLevelInner[0] = 1.0;\n"
    "                   Out[gl_InvocationID].upscale = n_tess;\n"
    "               }else\n"
    "               {\n"
    "                   gl_TessLevelOuter[0] = 0.0;\n"
    "                   gl_TessLevelOuter[1] = 0.0;\n"
    "                   gl_TessLevelOuter[2] = 0.0;\n"
    "                   gl_TessLevelInner[0] = 0.0;\n"
    "               }\n"
    "            }else\n"
    "            {\n"
    "               gl_TessLevelOuter[0] = max(tess_out_0,1.0);\n"
    "               gl_TessLevelOuter[1] = max(tess_out_1,1.0);\n"
    "               gl_TessLevelOuter[2] = max(tess_out_2,1.0);\n"
    "               gl_TessLevelInner[0] = tess_in_0;\n"
    "            }\n"
    "       }else\n"
    "       {\n"
    "           gl_TessLevelOuter[0] = 0.0;\n"
    "           gl_TessLevelOuter[1] = 0.0;\n"
    "           gl_TessLevelOuter[2] = 0.0;\n"
    "           gl_TessLevelInner[0] = 0.0;\n"
    "       }\n"
    "    }\n"
    "}\n";

static const char *tesselationevaluationShaderSource_SURFACE_TESSELATED =
    "#version 400\n"
    "\n"
    "layout( triangles, fractional_even_spacing, ccw ) in;\n"
    "in terrainVertex {\n"
    "    vec3 position;\n"
    "    flat float upscale; \n"
    "    flat vec3 referencepos; \n"
    "} In[];\n"
    "\n"
    " out worldVertex {\n"
    "     vec4 worldPosition;\n"
    "     vec4 position;\n"
    "     vec4 color;"
    "     vec3 patchdist; \n"
    "     flat float upscale; \n"
    "     float alpha; \n"
    "     flat vec3 referencepos; \n"
    " } Out;\n"
    "\n"
    "uniform sampler2D heightMap; \n"
    "\n"
    "uniform sampler2D microElevation; \n"
    "uniform float microElevationScaleX; \n"
    "uniform float microElevationScaleY; \n"
    "uniform float microElevationScaleZ; \n"
    "\n"
    "uniform float CellSize; \n"
    "uniform float SurfaceExtentX; \n"
    "uniform float SurfaceExtentZ; \n"
    "uniform float ElevationMin; \n"
    "uniform float ElevationMax; \n"
    "\n"
    "uniform highp mat4 Cmatrix;\n"
    "uniform highp mat4 Mmatrix;\n"
    "\n"
    "float getElevation(float xpos, float zpos)\n"
    "{\n"
    "    vec2 texcoord = vec2(xpos / SurfaceExtentX, zpos/SurfaceExtentZ);\n"
    "    float heightmap = texture(heightMap,texcoord).r;\n"
    "    vec2 texcoord2 = vec2(mod(xpos,microElevationScaleX) /microElevationScaleX, mod(zpos,microElevationScaleZ) /microElevationScaleZ);\n"
    "    float heightmap2 = microElevationScaleY * texture(microElevation,texcoord2).r;\n"
    "    return heightmap + heightmap2;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "   vec3 position = gl_TessCoord.x*In[0].position + gl_TessCoord.y*In[1].position + gl_TessCoord.z*In[2].position;\n"
    "   position.y = getElevation(position.x, position.z);\n"
    "   gl_Position = vec4(position, 1.0);\n"
    "   Out.worldPosition = vec4(position, 1.0);\n"
    "   Out.position = vec4(position, 1.0);\n"
    "   Out.patchdist = gl_TessCoord;\n"
    "   Out.upscale = In[0].upscale;\n"
    "   Out.alpha = position.y >-999?1.0:0.0;\n"
    "   Out.referencepos = In[0].referencepos;\n"
    "   float scaledval = (position.y - ElevationMin)/(ElevationMax - ElevationMin);\n"
    "   Out.color = vec4(1-scaledval,scaledval*scaledval,scaledval,1.0);\n"
    "}\n";
//;

static const char *geometryShaderSource_SURFACE_TESSELATED =
    "#version 400\n"
    "\n"
    "layout( triangles ) in;\n"
    "layout( triangle_strip, max_vertices = 3 ) out;\n"
    "\n"
    "in worldVertex {\n"
    "    vec4 worldPosition;\n"
    "    vec4 position;\n"
    "    vec4 color;\n"
    "    vec3 patchdist; \n"
    "    flat float upscale; \n"
    "    float alpha; \n"
    "    flat vec3 referencepos; \n"
    "} In[];\n"
    "\n"
    "out wireFrameVertex {\n"
    "    vec4 worldPosition;\n"
    "    vec4 position;\n"
    "    vec4 color;\n"
    "    vec3 patchdist; \n"
    "    vec3 tridist; \n"
    "    vec3 normal; \n"
    "    float alpha; \n"
    "} Out;\n"
    "\n"
    "\n"
    "uniform sampler2D heightMap; \n"
    "\n"
    "uniform sampler2D microElevation; \n"
    "uniform float microElevationScaleX; \n"
    "uniform float microElevationScaleY; \n"
    "uniform float microElevationScaleZ; \n"
    "\n"
    "uniform float CellSize; \n"
    "uniform float SurfaceExtentX; \n"
    "uniform float SurfaceExtentZ; \n"
    "uniform float ElevationMin; \n"
    "uniform float ElevationMax; \n"
    "\n"
    "uniform highp mat4 Cmatrix;\n"
    "uniform highp mat4 Mmatrix;\n"
    "\n"
    "float getElevation(float xpos, float zpos)\n"
    "{\n"
    "    vec2 texcoord = vec2(xpos / SurfaceExtentX, zpos/SurfaceExtentZ);\n"
    "    float heightmap = texture(heightMap,texcoord).r;\n"
    "    vec2 texcoord2 = vec2(mod(xpos,microElevationScaleX) /microElevationScaleX, mod(zpos,microElevationScaleZ) /microElevationScaleZ);\n"
    "    float heightmap2 = microElevationScaleY * texture(microElevation,texcoord2).r;\n"
    "    return heightmap + heightmap2;\n"
    "}\n"
    "void main() {\n"
    "\n"
    "   vec3 der_1 =(In[0].worldPosition - In[2].worldPosition).xyz;\n"
    "   vec3 der_2 =(In[0].worldPosition - In[1].worldPosition).xyz;\n"
    "   vec3 normal = normalize(cross(der_1,der_2));\n"
    "\n"
    "   vec3 referencepos = In[0].referencepos;\n"
    "   vec4 position0 = In[0].worldPosition;\n"
    "   vec4 position1 = In[1].worldPosition;\n"
    "   vec4 position2 = In[2].worldPosition;\n"
    "\n"
    "\n"
    "    float upscale = max(max(In[0].upscale,In[2].upscale),In[1].upscale);\n"
    "   if(upscale > 1.0) \n"
    "   {\n"
    "   position0.xz = (position0.xz -referencepos.xz) * upscale + referencepos.xz;\n"
    "   position1.xz = (position1.xz -referencepos.xz) * upscale + referencepos.xz;\n"
    "   position2.xz = (position2.xz -referencepos.xz) * upscale + referencepos.xz;\n"
    "   position0.y = getElevation(position0.x,position0.z);\n"
    "   position1.y = getElevation(position1.x,position1.z);\n"
    "   position2.y = getElevation(position2.x,position2.z);\n"
    "   }\n"
    "\n"
    "   Out.worldPosition = position0;\n"
    "   Out.position = Cmatrix *position0;\n"
    "   Out.color = In[0].color;\n"
    "   Out.patchdist = In[0].patchdist;\n"
    "   Out.tridist = vec3(1.0,0.0,0.0);\n"
    "   Out.normal = normal;\n"
    "   Out.alpha = In[0].alpha;\n"
    "   gl_Position = Cmatrix *position0; EmitVertex();\n"
    "\n"
    "   Out.worldPosition = position1;\n"
    "   Out.position = Cmatrix *position1;\n"
    "   Out.color = In[1].color;\n"
    "   Out.patchdist = In[1].patchdist;\n"
    "   Out.tridist = vec3(0.0,1.0,0.0);\n"
    "   Out.normal = normal;\n"
    "   Out.alpha = In[1].alpha;\n"
    "   gl_Position = Cmatrix *position1; EmitVertex();\n"
    "\n"
    "   Out.worldPosition = position2;\n"
    "   Out.position = Cmatrix *position2;\n"
    "   Out.color = In[2].color;\n"
    "   Out.patchdist = In[2].patchdist;\n"
    "   Out.tridist = vec3(0.0,0.0,1.0);\n"
    "   Out.normal = normal;\n"
    "   Out.alpha = In[2].alpha;\n"
    "   gl_Position = Cmatrix *position2; EmitVertex();\n"
    "\n"
    "}\n";
//;

static const char *fragmentShaderSource_SURFACE_TESSELATED =
    "#version 400\n"
    "\n"
    "out vec4 FragColor;\n"
    "in wireFrameVertex {\n"
    "    vec4 worldPosition;\n"
    "    vec4 position;\n"
    "    vec4 color;\n"
    "    vec3 patchdist; \n"
    "    vec3 tridist; \n"
    "    vec3 normal; \n"
    "    float alpha; \n"
    "};\n"
    "\n"
    "uniform float CellSize; \n"
    "uniform float SurfaceExtentX; \n"
    "uniform float SurfaceExtentZ; \n"
    "uniform float ElevationMin; \n"
    "uniform float ElevationMax; \n"
    "uniform vec3 Cposition; \n"
    "float amplify(float d, float scale, float offset)\n"
    "{\n"
    "    d = scale * d + offset;\n"
    "    d = clamp(d, 0, 1);\n"
    "    d = 1 - exp2(-2*d*d);\n"
    "    return d;\n"
    "}\n"
    "\n"
    "uniform sampler2D heightMap; \n"
    "uniform sampler2D microElevation; \n"
    "uniform sampler2D mask; \n"
    "\n"
    "uniform float microElevationScaleX; \n"
    "uniform float microElevationScaleY; \n"
    "uniform float microElevationScaleZ; \n"
    "uniform float TextureSizeX;\n"
    "uniform float TextureSizeZ;\n"
    "uniform sampler2D grass_color; \n"
    "uniform sampler2D grass_bump; \n"
    "uniform sampler2D grass_normal; \n"
    "uniform sampler2D gravel_color; \n"
    "uniform sampler2D gravel_bump; \n"
    "uniform sampler2D gravel_normal; \n"
    "uniform sampler2D stone_color; \n"
    "uniform sampler2D stone_bump; \n"
    "uniform sampler2D stone_normal; \n"
    "\n"
    "float getMicroElevation(float xpos, float zpos)\n"
    "{\n"
    "    vec2 texcoord2 = vec2(mod(xpos,microElevationScaleX) /microElevationScaleX, mod(zpos,microElevationScaleZ) /microElevationScaleZ);\n"
    "    float heightmap2 = microElevationScaleY * texture(microElevation,texcoord2).r;\n"
    "    return heightmap2;\n"
    "}\n"
    "float getMask(float xpos, float zpos)\n"
    "{\n"
    "    vec2 texcoord = vec2(xpos / SurfaceExtentX, zpos/SurfaceExtentZ);\n"
    "    float maskmap = texture(mask,texcoord).r;\n"
    "    return maskmap;\n"
    "}\n"
    "\n"
    "vec2 getSurfaceTexCords(float xpos, float zpos)\n"
    "{\n"
    "    vec2 texcoord = vec2(xpos / TextureSizeX, zpos/TextureSizeZ);\n"
    "    return texcoord;\n"
    "}\n"
    "\n"
    "vec3 getPhongLighting(vec3 normal)\n"
    "{\n"
    "    vec3 light = vec3(0.3,0.3,0.3) + abs(dot(normalize(normal),vec3(-2,-1,0))) *1.0;\n"
    "    return light;\n"
    "}\n"
    "void main() {\n"
    "   float maskc = getMask(worldPosition.x, worldPosition.z);\n"
    "   float d1 = min(min(patchdist.x, patchdist.y), patchdist.z);\n"
    "   float d2 = min(min(tridist.x, tridist.y), tridist.z);\n"
    "   if(maskc * alpha < 0.05){discard; }\n"
    "   float microelev = getMicroElevation(worldPosition.x,worldPosition.z);\n"
    "   FragColor = vec4( getPhongLighting(normal) *texture(grass_color,getSurfaceTexCords(worldPosition.x,worldPosition.z)).rgb,maskc *alpha);\n"
    "}\n";

//vec4(amplify(d1, 40, -0.5) * amplify(d2, 30, -0.5) *
/////////////////////////////////////////////////////////////////////////////////////
///Simple flowsurface shader
/////////////////////////////////////////////////////////////////////////////////////
static const char *vertexShaderSource_FLOWSURFACE =
    "in highp vec3 posAttr;\n"
    "in lowp vec3 colAttr;\n"
    "uniform highp mat4 Cmatrix;\n"
    "uniform highp mat4 Mmatrix;\n"
    "out lowp vec4 col;\n"
    "void main() {\n"
    "   gl_Position = Cmatrix *vec4(posAttr, 1.0);\n"
    "   col = vec4(colAttr,1.0);\n"
    "}\n";
//;
static const char *fragmentShaderSource_FLOWSURFACE =
    "in lowp vec4 col;\n"
    "void main() {\n"
    "   gl_FragColor = col;\n"
    "}\n";
/////////////////////////////////////////////////////////////////////////////////////
///Simple vegetation shader
/////////////////////////////////////////////////////////////////////////////////////
static const char *vertexShaderSource_VEGETATION =
    "in highp vec3 posAttr;\n"
    "in lowp vec3 colAttr;\n"
    "uniform highp mat4 Cmatrix;\n"
    "uniform highp mat4 Mmatrix;\n"
    "out lowp vec4 col;\n"
    "void main() {\n"
    "   gl_Position = Cmatrix *vec4(posAttr, 1.0);\n"
    "   col = vec4(colAttr,1.0);\n"
    "}\n";
//;
static const char *fragmentShaderSource_VEGETATION =
    "in lowp vec4 col;\n"
    "void main() {\n"
    "   gl_FragColor = col;\n"
    "}\n";
/////////////////////////////////////////////////////////////////////////////////////
///Simple textures shader
/////////////////////////////////////////////////////////////////////////////////////
static const char *vertexShaderSource_TEXTURED =
    "in highp vec3 posAttr;\n"
    "in lowp vec3 colAttr;\n"
    "uniform highp mat4 Cmatrix;\n"
    "uniform highp mat4 Mmatrix;\n"
    "out lowp vec4 col;\n"
    "void main() {\n"
    "   gl_Position = vec4(posAttr, 1.0);\n"
    "}\n";

static const char *fragmentShaderSource_TEXTURED =
    "in lowp vec4 col;\n"
    "void main() {\n"
    "   gl_FragColor = col;\n"
    "}\n";
/////////////////////////////////////////////////////////////////////////////////////
///Surface shader with tesselation, using this, efficient micro-surfaces can be rendered for large scale areas
/////////////////////////////////////////////////////////////////////////////////////
static const char *vertexShaderSource_SURFACE_TESSELATED2 =
    "#version 400\n"
    "\n"
    "in highp vec2 posAttr;\n"
    "uniform highp mat4 Cmatrix;\n"
    "uniform highp mat4 Mmatrix;\n"
    " \n"
    "out terrainVertex {\n"
    "    vec2 position;\n"
    "} Out;\n"
    " \n"
    "void main() {\n"
    "   Out.position = posAttr;//vec2(vec4(Mmatrix *vec4(posAttr,1.0)).xy);\n"
    "}\n";

static const char *tesselationcontrolShaderSource_SURFACE_TESSELATED2 =
    "#version 400\n"
    "\n"
    "layout(vertices = 3) out;\n"
    "\n"
    "in terrainVertex {\n"
    "   vec2 position; \n"
    "} In[]; \n"
    "\n"
    "out terrainVertex {\n"
    "   vec2 position; \n"
    "} Out[]; \n"
    "\n"
    "uniform float tesselationLevel = 64.0;\n"
    "\n"
    "uniform sampler2D heightMap; \n"
    "uniform int maxTrianglesPerTexel = 10;\n"
    "uniform float horizontalScale = 10.0;\n"
    "uniform float verticalScale = 0.4;\n"
    "\n"
    "uniform mat4 mvp; \n"
    "uniform float pixelsPerTriangleEdge = 12.0;\n"
    "uniform vec2 viewportSize;\n"
    "uniform float TessLevel = 1.0;\n"
    "\n"
    "const float maxTessLevel = 64.0;\n"
    "\n"
    "bool isEdgeInViewFrustum( const in vec4 p1, const in vec4 p2 )\n"
    "{\n"
    "   return !( ( p1.x < -p1.w && p2.x < -p2.w )\n"
    "           || ( p1.x >  p1.w && p2.x >  p2.w )\n"
    "           || ( p1.y < -p1.w && p2.y < -p2.w )\n"
    "           || ( p1.y >  p1.w && p2.y >  p2.w )\n"
    "           || ( p1.z < -p1.w && p2.z < -p2.w )\n"
    "           || ( p1.z >  p1.w && p2.z >  p2.w ) );\n"
    "}\n"
    "\n"
    "float calcTessellationLevel( const in vec4 v1, const in vec4 v2 )\n"
    "{\n"
    "    vec4 p1 = 0.5 * ( v1 + v2 );\n"
    "    vec4 p2 = p1;\n"
    "    p2.y += distance( v1, v2 );\n"
    "    p1 = p1 / p1.w;\n"
    "    p2 = p2 / p2.w;\n"
    "    float l = length( 0.5 * viewportSize * ( p1.xy - p2.xy ) );\n"
    "    return clamp( l / pixelsPerTriangleEdge, 1.0, 64.0 );\n"
    "    }"
    "\n"
    "void main()\n"
    "{\n"
    "\n"
    "    Out[gl_InvocationID].position = In[gl_InvocationID].position;\n"
            /*"    vec2 patchExtent = maxTessLevel / ( textureSize( heightMap, 0 ) * maxTrianglesPerTexel );\n"
            "\n"
            "\n"
            "    vec2 patchCornersXZ[4];\n"
            "    patchCornersXZ[0] = Out[gl_InvocationID].position;                              // min x, min z\n"
            "    patchCornersXZ[1] = Out[gl_InvocationID].position + vec2( 0.0, patchExtent.y ); // min x, max z\n"
            "    patchCornersXZ[2] = Out[gl_InvocationID].position + vec2( patchExtent.x, 0.0 ); // max x, min z\n"
            "    patchCornersXZ[3] = Out[gl_InvocationID].position + patchExtent;                // max x, max z\n"
            "\n"
            "    vec4 clipSpacePatchCorners[4];\n"
            "    for ( int i = 0; i < 4; i++ )\n"
            "    {\n"
            "        vec4 position;\n"
            "        position.xz = patchCornersXZ[i] * horizontalScale;\n"
            "        position.y = verticalScale * texture( heightMap, patchCornersXZ[i] ).r;\n"
            "        position.w = 1.0;\n"
            "\n"
            "        // Transform to clip-space\n"
            "        clipSpacePatchCorners[i] = mvp * position;\n"
            "    }\n"
            "\n"
            "    // Determine if we can cull this patch\n"
            "    if ( isEdgeInViewFrustum( clipSpacePatchCorners[0], clipSpacePatchCorners[2] )\n"
            "      || isEdgeInViewFrustum( clipSpacePatchCorners[0], clipSpacePatchCorners[1] )\n"
            "      || isEdgeInViewFrustum( clipSpacePatchCorners[1], clipSpacePatchCorners[3] )\n"
            "      || isEdgeInViewFrustum( clipSpacePatchCorners[2], clipSpacePatchCorners[3] ) )\n"
            "    {\n"
            "        gl_TessLevelOuter[0] = calcTessellationLevel( clipSpacePatchCorners[0], clipSpacePatchCorners[1] ); // x = min,   z = const\n"
            "        gl_TessLevelOuter[1] = calcTessellationLevel( clipSpacePatchCorners[0], clipSpacePatchCorners[2] ); // x = const, z = min\n"
            "        gl_TessLevelOuter[2] = calcTessellationLevel( clipSpacePatchCorners[2], clipSpacePatchCorners[3] ); // x = max,   z = const\n"
            "        gl_TessLevelOuter[3] = calcTessellationLevel( clipSpacePatchCorners[1], clipSpacePatchCorners[3] ); // x = const, z = max\n"
            "        gl_TessLevelInner[0] = max( gl_TessLevelOuter[1], gl_TessLevelOuter[3] ); // z = const\n"
            "        gl_TessLevelInner[1] = max( gl_TessLevelOuter[0], gl_TessLevelOuter[2] ); // x = const\n"
            "    }\n"
            "    else\n"
            "    {\n"
            "        \n"
            "        gl_TessLevelOuter[0] = 0.0;\n"
            "        gl_TessLevelOuter[1] = 0.0;\n"
            "        gl_TessLevelOuter[2] = 0.0;\n"
            "        gl_TessLevelOuter[3] = 0.0;\n"
            "        gl_TessLevelInner[0] = 0.0;\n"
            "        gl_TessLevelInner[1] = 0.0;\n"
            "    }\n"*/
    "        \n"
    "        gl_TessLevelOuter[0] = 2.0;\n"
    "        gl_TessLevelOuter[1] = 2.0;\n"
    "        gl_TessLevelOuter[2] = 2.0;\n"
    "        gl_TessLevelOuter[3] = 2.0;\n"
    "        gl_TessLevelInner[0] = 2.0;\n"
    "        gl_TessLevelInner[1] = 2.0;\n"

    "}\n";

static const char *tesselationevaluationShaderSource_SURFACE_TESSELATED2 =
    "#version 400\n"
    "\n"
    "layout( quads, fractional_even_spacing, cw ) in;\n"
    "\n"
    "in terrainVertex {\n"
    "    vec2 position;\n"
    "} In[];\n"
    "\n"
    " out worldVertex {\n"
    "     vec4 worldPosition;\n"
    "     vec3 worldNormal;\n"
    "     vec4 position;\n"
    "     vec3 normal;\n"
    "     vec2 texCoords;\n"
    " } Out;\n"
    "\n"
    " uniform sampler2D heightMap;\n"
    "\n"
    " // The number of triangles created per height-map texel\n"
    " uniform int maxTrianglesPerTexel = 10;\n"
    "\n"
    " // Distance between each tessellation point at max tess level\n"
    " uniform float horizontalScale = 10.0;\n"
    "\n"
    " // Vertical scale to multiply height samples by\n"
    " uniform float verticalScale = 0.4;\n"
    "\n"
    " // Transformation matrices\n"
    " uniform mat4 modelMatrix;\n"
    " uniform mat4 modelViewMatrix;\n"
    " uniform mat3 worldNormalMatrix;\n"
    " uniform mat3 normalMatrix;\n"
    " uniform mat4 mvp;\n"
    "\n"
    " const float maxTessLevel = 64.0;\n"
    "\n"
    " void main()\n"
    " {\n"
            /*"     // Calculate extent of this patch in texture coords [0,1]\n"
            "     vec2 patchExtent = maxTessLevel / ( textureSize( heightMap, 0 ) * maxTrianglesPerTexel );\n"
            "\n"
            "     // Calculate the texture coordinates\n"
            "     Out.texCoords = In[0].position.xy + gl_TessCoord.xy * patchExtent;\n"
            "\n"
            "     // Calculate the model-space position\n"
            "     vec4 position;\n"
            "     position.xz = Out.texCoords * horizontalScale;\n"
            "     position.y = verticalScale * texture( heightMap, Out.texCoords ).r;\n"
            "     position.w = 1.0;\n"
            "\n"
            "     // Transform the position to world coordinates and to eye space\n"
            "     Out.worldPosition = modelMatrix * position;\n"
            "     Out.position = modelViewMatrix * position;\n"
            "\n"
            "     // Calculate the normal\n"
            "     // This could be moved to a one-time pre-process step to create a normal map.\n"
            "     // This would be a good candidate for a compute shader.\n"
            "     // For deformable terrain, would need re-generating when terrain is modified\n"
            "     const ivec3 offset = ivec3( -1, 0, 1 ); // Texel offsets\n"
            "     float delta = 2.0 * horizontalScale / textureSize( heightMap, 0 ).x; // Horizontal displacement in world coords\n"
            "     float left   = verticalScale * textureOffset( heightMap, Out.texCoords, offset.xy ).r;\n"
            "     float right  = verticalScale * textureOffset( heightMap, Out.texCoords, offset.zy ).r;\n"
            "     float top    = verticalScale * textureOffset( heightMap, Out.texCoords, offset.yz ).r;\n"
            "     float bottom = verticalScale * textureOffset( heightMap, Out.texCoords, offset.yx ).r;\n"
            "\n"
            "     vec3 x = normalize( vec3( delta, right - left, 0.0 ) );\n"
            "     vec3 z = normalize( vec3( 0.0, top - bottom, delta ) );\n"
            "     vec3 n = cross( z, x );\n"
            "     Out.worldNormal = worldNormalMatrix * n;\n"
            "     Out.normal = normalMatrix * n;\n"
            "\n"*/

    "     vec4 position.xy = In[0].position.xy / 2000.0;\n"
    "     position.z = 0.5;\n"
    "     position.w = 0.5;\n"
    "     Out.worldPosition = modelMatrix * position;\n"
    "     Out.position = modelViewMatrix * position;\n"

    "     // Transform to clip-space\n"
    "     //gl_Position = mvp * position;\n"
    " }\n";

static const char *geometryShaderSource_SURFACE_TESSELATED2 =
        "#version 400\n"
        "\n"
        "layout( triangles ) in;\n"
        "layout( triangle_strip, max_vertices = 3 ) out;\n"
        "\n"
        "in worldVertex {\n"
        "    vec4 worldPosition;\n"
        "    vec3 worldNormal;\n"
        "    vec4 position;\n"
        "    vec3 normal;\n"
        "    vec2 texCoords;\n"
        "} In[];\n"
        "\n"
        "out wireFrameVertex {\n"
        "    noperspective vec3 edgeDistance;\n"
        "    vec4 worldPosition;\n"
        "    vec3 worldNormal;\n"
        "    vec4 position;\n"
        "    vec3 normal;\n"
        "    vec2 texCoords;\n"
        "} Out;\n"
        "\n"
        "uniform mat4 viewportMatrix;\n"
        "\n"
        "void main()\n"
        "{\n"
        "    // Transform each vertex into viewport space\n"
        "    vec2 p0 = vec2( viewportMatrix * ( gl_in[0].gl_Position / gl_in[0].gl_Position.w ) );\n"
        "    vec2 p1 = vec2( viewportMatrix * ( gl_in[1].gl_Position / gl_in[1].gl_Position.w ) );\n"
        "    vec2 p2 = vec2( viewportMatrix * ( gl_in[2].gl_Position / gl_in[2].gl_Position.w ) );\n"
        "\n"
        "    // Calculate lengths of 3 edges of triangle\n"
        "    float a = length( p1 - p2 );\n"
        "    float b = length( p2 - p0 );\n"
        "    float c = length( p1 - p0 );\n"
        "\n"
        "    // Calculate internal angles using the cosine rule\n"
        "    float alpha = acos( ( b * b + c * c - a * a ) / ( 2.0 * b * c ) );\n"
        "    float beta = acos( ( a * a + c * c - b * b ) / ( 2.0 * a * c ) );\n"
        "\n"
        "    // Calculate the perpendicular distance of each vertex from the opposing edge\n"
        "    float ha = abs( c * sin( beta ) );\n"
        "    float hb = abs( c * sin( alpha ) );\n"
        "    float hc = abs( b * sin( alpha ) );    \n"
        "\n"
        "    // Now add this perpendicular distance as a per-vertex property in addition to\n"
        "    // the position calculated in the vertex shader.\n"
        "\n"
        "\n"
        "    // Vertex 0 (a)\n"
        "    Out.edgeDistance = vec3( ha, 0, 0 );\n"
        "    Out.worldPosition = In[0].worldPosition;\n"
        "    Out.worldNormal = In[0].worldNormal;\n"
        "    Out.position = In[0].position;\n"
        "    Out.normal = In[0].normal;\n"
        "    Out.texCoords = In[0].texCoords;\n"
        "    gl_Position = vec4(0.0,0.0,0.5,0.5);//gl_in[0].gl_Position;\n"
        "    EmitVertex();\n"
        "\n"
        "\n"
        "    // Vertex 1 (b)\n"
        "    Out.edgeDistance = vec3( 0, hb, 0 );\n"
        "    Out.worldPosition = In[1].worldPosition;\n"
        "    Out.worldNormal = In[1].worldNormal;\n"
        "    Out.position = In[1].position;\n"
        "    Out.normal = In[1].normal;\n"
        "    Out.texCoords = In[1].texCoords;\n"
        "    gl_Position = vec4(0.0,1.0,0.5,0.5);gl_in[1].gl_Position;\n"
        "    EmitVertex();\n"
        "\n"
        "\n"
        "    // Vertex 2 (c)\n"
        "    Out.edgeDistance = vec3( 0, 0, hc );\n"
        "    Out.worldPosition = In[2].worldPosition;\n"
        "    Out.worldNormal = In[2].worldNormal;\n"
        "    Out.position = In[2].position;\n"
        "    Out.normal = In[2].normal;\n"
        "    Out.texCoords = In[2].texCoords;\n"
        "    gl_Position = vec4(1.0,0.0,0.5,0.5);gl_in[2].gl_Position;\n"
        "    EmitVertex();\n"
        "\n"
        "    // Finish the primitive off\n"
        "    EndPrimitive();\n"
        "}\n";


static const char *fragmentShaderSource_SURFACE_TESSELATED2 =
        "#version 400\n"
        "\n"
        "subroutine vec4 ShaderModelType();\n"
        "subroutine uniform ShaderModelType shaderModel;\n"
        "\n"
        "uniform struct LineInfo {\n"
        "  float width;\n"
        "  vec4 color;\n"
        "} line;\n"
        "\n"
        "uniform struct FogInfo {\n"
        "    vec4 color;\n"
        "    float minDistance;\n"
        "    float maxDistance;\n"
        "} fog;\n"
        "\n"
        "uniform struct LightInfo\n"
        "{\n"
        "    vec4 position;  // Light position in eye coords.\n"
        "    vec3 intensity;\n"
        "} light;\n"
        "\n"
        "uniform struct MaterialInfo\n"
        "{\n"
        "    vec3 Ka;            // Ambient reflectivity\n"
        "    vec3 Kd;            // Diffuse reflectivity\n"
        "    vec3 Ks;            // Specular reflectivity\n"
        "    float shininess;    // Specular shininess exponent\n"
        "} material;\n"
        "\n"
        "uniform sampler2D grassTexture;\n"
        "uniform sampler2D rockTexture;\n"
        "uniform sampler2D snowTexture;\n"
        "\n"
        "uniform float colorStop1 = 0.0;\n"
        "uniform float colorStop2 = 4.0;\n"
        "uniform float colorStop3 = 8.0;\n"
        "uniform float colorStop4 = 12.0;\n"
        "\n"
        "uniform vec4 color1 = vec4( 0.00, 0.55, 0.00, 1.00 );\n"
        "uniform vec4 color2 = vec4( 0.89, 0.68, 0.00, 1.00 );\n"
        "uniform vec4 color3 = vec4( 0.75, 0.00, 0.00, 1.00 );\n"
        "uniform vec4 color4 = vec4( 1.00, 1.00, 1.00, 1.00 );\n"
        "\n"
        "in wireFrameVertex {\n"
        "    noperspective vec3 edgeDistance;\n"
        "    vec4 worldPosition;\n"
        "    vec3 worldNormal;\n"
        "    vec4 position;\n"
        "    vec3 normal;\n"
        "    vec2 texCoords;\n"
        "};\n"
        "\n"
        "layout (location = 0) out vec4 fragColor;\n"
        "\n"
        "// Helper functions\n"
        "vec4 linearGradient( const in float t )\n"
        "{\n"
        "    vec4 color;\n"
        "    if ( t < colorStop1 )\n"
        "    {\n"
        "        color = color1;\n"
        "    }\n"
        "    else if ( t < colorStop2 )\n"
        "    {\n"
        "        float tLocal = ( t - colorStop1 ) / ( colorStop2 - colorStop1 );\n"
        "        color = mix( color1, color2, tLocal );\n"
        "    }\n"
        "    else if ( t < colorStop3 )\n"
        "    {\n"
        "        float tLocal = ( t - colorStop2 ) / ( colorStop3 - colorStop2 );\n"
        "        color = mix( color2, color3, tLocal );\n"
        "    }\n"
        "    else if ( t < colorStop4 )\n"
        "    {\n"
        "        float tLocal = ( t - colorStop3 ) / ( colorStop4 - colorStop3 );\n"
        "        color = mix( color3, color4, tLocal );\n"
        "    }\n"
        "    else\n"
        "    {\n"
        "        color = color4;\n"
        "    }\n"
        "\n"
        "    return color;\n"
        "}\n"
        "\n"
        "void phongModel( out vec3 ambientAndDiff, out vec3 spec )\n"
        "{\n"
        "    // Some useful vectors\n"
        "    vec3 s = normalize( vec3( light.position )/* - position.xyz*/ );\n"
        "    vec3 v = normalize( -position.xyz );\n"
        "    vec3 n = normalize( normal );\n"
        "    vec3 r = reflect( -s, n );\n"
        "\n"
        "    // Calculate the ambient contribution\n"
        "    vec3 ambient = light.intensity * material.Ka;\n"
        "\n"
        "    // Calculate the diffuse contribution\n"
        "    float sDotN = max( dot( s, n ), 0.0 );\n"
        "    vec3 diffuse = light.intensity * material.Kd * sDotN;\n"
        "\n"
        "    // Sum the ambient and diffuse contributions\n"
        "    ambientAndDiff = ambient + diffuse;\n"
        "\n"
        "    // Calculate the specular highlight component\n"
        "    spec = vec3( 0.0 );\n"
        "    if ( sDotN > 0.0 )\n"
        "    {\n"
        "        spec = light.intensity * material.Ks * pow( max( dot( r, v ), 0.0 ), material.shininess );\n"
        "    }\n"
        "}\n"
        "\n"
        "vec4 wireFrame( const in vec4 color, const in vec4 wireFrameColor )\n"
        "{\n"
        "    // Find the smallest distance between the fragment and a triangle edge\n"
        "    float d = min( edgeDistance.x, edgeDistance.y );\n"
        "    d = min( d, edgeDistance.z );\n"
        "\n"
        "    // Blend between line color and triangle color\n"
        "    float mixVal;\n"
        "    if ( d < line.width - 0.5 )\n"
        "    {\n"
        "        mixVal = 1.0;\n"
        "    }\n"
        "    else if ( d > line.width + 0.5 )\n"
        "    {\n"
        "        mixVal = 0.0;\n"
        "    }\n"
        "    else\n"
        "    {\n"
        "        float x = d - ( line.width - 1.0 );\n"
        "        mixVal = exp2( -2.0 * ( x * x ) );\n"
        "    }\n"
        "    vec4 c = mix( color, wireFrameColor, mixVal );\n"
        "    return c;\n"
        "}\n"
        "\n"
        "float textureDistanceBlendFactor()\n"
        "{\n"
        "    float dist = abs( position.z );\n"
        "    return ( dist - 30.0 ) / ( 30.0 - 5.0 );\n"
        "}\n"
        "\n"
        "void nearAndFarTexCoords( out vec2 uvNear, out vec2 uvFar )\n"
        "{\n"
        "    uvNear = texCoords * 100.0;\n"
        "    uvFar = texCoords * 10.0;\n"
        "}\n"
        "\n"
        "// ShaderModelType Subroutines\n"
        "subroutine( ShaderModelType )\n"
        "vec4 shadeSimpleWireFrame()\n"
        "{\n"
        "    vec4 color = vec4( 1.0 );\n"
        "    return wireFrame( color, line.color );\n"
        "}\n"
        "\n"
        "subroutine( ShaderModelType )\n"
        "vec4 shadeWorldHeight()\n"
        "{\n"
        "    vec4 color = linearGradient( worldPosition.y );\n"
        "    return wireFrame( color, 0.7 * color );\n"
        "}\n"
        "\n"
        "subroutine( ShaderModelType )\n"
        "vec4 shadeWorldNormal()\n"
        "{\n"
        "    return vec4( 0.5 * ( worldNormal + vec3( 1.0 ) ), 1.0 );\n"
        "}\n"
        "\n"
        "subroutine( ShaderModelType )\n"
        "vec4 shadeGrass()\n"
        "{\n"
        "    vec2 uvNear, uvFar;\n"
        "    nearAndFarTexCoords( uvNear, uvFar );\n"
        "    float textureDistanceFactor = textureDistanceBlendFactor();\n"
        "\n"
        "    // Get grass texture color\n"
        "    vec4 grassNear = texture( grassTexture, uvNear );\n"
        "    vec4 grassFar = texture( grassTexture, texCoords );\n"
        "    vec4 grassColor = mix( grassNear, grassFar, textureDistanceFactor );\n"
        "    return grassColor;\n"
        "}\n"
        "\n"
        "subroutine( ShaderModelType )\n"
        "vec4 shadeGrassAndRocks()\n"
        "{\n"
        "    vec2 uvNear, uvFar;\n"
        "    nearAndFarTexCoords( uvNear, uvFar );\n"
        "    float textureDistanceFactor = textureDistanceBlendFactor();\n"
        "\n"
        "    // Get grass texture color\n"
        "    vec4 grassNear = texture( grassTexture, uvNear );\n"
        "    vec4 grassFar = texture( grassTexture, texCoords );\n"
        "    vec4 grassColor = mix( grassNear, grassFar, textureDistanceFactor );\n"
        "\n"
        "    // Get rock texture color\n"
        "    vec4 rockNear = texture( rockTexture, uvNear );\n"
        "    vec4 rockFar = texture( rockTexture, uvFar );\n"
        "    vec4 rockColor = mix( rockNear, rockFar, textureDistanceFactor );\n"
        "\n"
        "    // Blend rock and grass texture based upon the worldNormal vector\n"
        "    vec4 grassRockColor = mix( rockColor, grassColor, smoothstep( 0.75, 0.95, clamp( worldNormal.y, 0.0, 1.0 ) ) );\n"
        "    return grassRockColor;\n"
        "}\n"
        "\n"
        "subroutine( ShaderModelType )\n"
        "vec4 shadeGrassRocksAndSnow()\n"
        "{\n"
        "    vec2 uvNear, uvFar;\n"
        "    nearAndFarTexCoords( uvNear, uvFar );\n"
        "    float textureDistanceFactor = textureDistanceBlendFactor();\n"
        "\n"
        "    // Get grass texture color\n"
        "    vec4 grassNear = texture( grassTexture, uvNear );\n"
        "    vec4 grassFar = texture( grassTexture, texCoords );\n"
        "    vec4 grassColor = mix( grassNear, grassFar, textureDistanceFactor );\n"
        "\n"
        "    // Get rock texture color\n"
        "    vec4 rockNear = texture( rockTexture, uvNear );\n"
        "    vec4 rockFar = texture( rockTexture, uvFar );\n"
        "    vec4 rockColor = mix( rockNear, rockFar, textureDistanceFactor );\n"
        "\n"
        "    // Blend rock and grass texture based upon the worldNormal vector\n"
        "    vec4 grassRockColor = mix( rockColor, grassColor, smoothstep( 0.75, 0.95, clamp( worldNormal.y, 0.0, 1.0 ) ) );\n"
        "\n"
        "    // Now blend with snow based upon world height\n"
        "    vec4 snowNear = texture( snowTexture, uvNear );\n"
        "    vec4 snowFar = texture( snowTexture, 5.0 * uvFar );\n"
        "    vec4 snowColor = mix( snowNear, snowFar, textureDistanceFactor );\n"
        "\n"
        "    vec4 diffuseColor = mix( grassRockColor, snowColor, smoothstep( 10.0, 15.0, worldPosition.y ) );\n"
        "    return diffuseColor;\n"
        "}\n"
        "\n"
        "subroutine( ShaderModelType )\n"
        "vec4 shadeLightingFactors()\n"
        "{\n"
        "    vec3 ambientAndDiff, spec;\n"
        "    phongModel( ambientAndDiff, spec );\n"
        "    vec4 lightingFactors = vec4( ambientAndDiff, 1.0 ) + vec4( spec, 1.0 );\n"
        "    return lightingFactors;\n"
        "}\n"
        "\n"
        "subroutine( ShaderModelType )\n"
        "vec4 shadeTexturedAndLit()\n"
        "{\n"
        "    vec2 uvNear, uvFar;\n"
        "    nearAndFarTexCoords( uvNear, uvFar );\n"
        "    float textureDistanceFactor = textureDistanceBlendFactor();\n"
        "\n"
        "    // Get grass texture color\n"
        "    vec4 grassNear = texture( grassTexture, uvNear );\n"
        "    vec4 grassFar = texture( grassTexture, texCoords );\n"
        "    vec4 grassColor = mix( grassNear, grassFar, textureDistanceFactor );\n"
        "\n"
        "    // Get rock texture color\n"
        "    vec4 rockNear = texture( rockTexture, uvNear );\n"
        "    vec4 rockFar = texture( rockTexture, uvFar );\n"
        "    vec4 rockColor = mix( rockNear, rockFar, textureDistanceFactor );\n"
        "\n"
        "    // Blend rock and grass texture based upon the worldNormal vector\n"
        "    vec4 grassRockColor = mix( rockColor, grassColor, smoothstep( 0.75, 0.95, clamp( worldNormal.y, 0.0, 1.0 ) ) );\n"
        "\n"
        "    // Now blend with snow based upon world height\n"
        "    vec4 snowNear = texture( snowTexture, uvNear );\n"
        "    vec4 snowFar = texture( snowTexture, 5.0 * uvFar );\n"
        "    vec4 snowColor = mix( snowNear, snowFar, textureDistanceFactor );\n"
        "\n"
        "    vec4 diffuseColor = mix( grassRockColor, snowColor, smoothstep( 10.0, 15.0, worldPosition.y ) );\n"
        "\n"
        "    // Calculate the lighting model, keeping the specular component separate\n"
        "    vec3 ambientAndDiff, spec;\n"
        "    phongModel( ambientAndDiff, spec );\n"
        "    vec4 color = vec4( ambientAndDiff, 1.0 ) * diffuseColor + vec4( spec, 1.0 );\n"
        "    return color;\n"
        "}\n"
        "\n"
        "void main()\n"
        "{\n"
        "    // Compute fragment color depending upon selected shading mode\n"
        "    //vec4 c = shaderModel();\n"
        "\n"
        "    // Blend with fog color\n"
        "    float dist = abs( position.z );\n"
        "    float fogFactor = ( fog.maxDistance - dist ) / ( fog.maxDistance - fog.minDistance );\n"
        "    fogFactor = clamp( fogFactor, 0.0, 1.0 );\n"
        "    fragColor = vec4(1.0,1.0,1.0,1.0);//mix( fog.color, c, fogFactor );\n"
        "}\n";

#endif
